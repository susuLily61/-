---
cssclasses:
---

### 🧠 1. 线程与进程之间的关系

**一眼记忆点：**  
进程是资源分配的最小单位；线程是 CPU 调度的最小单位。

**理解思路：**

- 一个进程就像一个“容器”，里面包含代码、数据、内存、文件描述符等资源。
    
- 线程是进程内部的执行流，一个进程至少有一个主线程。
    
- 同一进程的多个线程共享堆和方法区，但各自有独立的栈和程序计数器。
    

**延伸补充：**

- 优点：线程间通信效率高；
    
- 缺点：共享资源会带来同步问题（死锁、竞争条件）。
    
- JVM 内部：JVM 本身是一个进程，线程包括 GC 线程、JIT 编译线程、用户线程等。

---

### 💬 2. 线程通信 vs 进程通信

**一眼记忆点：**  
线程通信靠**共享内存**，进程通信靠**内核机制**。

**理解思路：**

- **线程通信**：因为线程共享内存，所以常见通信方式有：
    
    - 共享变量（synchronized、volatile）
        
    - 等待/通知机制（wait/notify）
        
    - 条件变量（Condition）
        
    - 队列（BlockingQueue）
        
- **进程通信（IPC）**：进程之间隔离，需要操作系统中介：
    
    - 管道（pipe）
        
    - 消息队列（message queue）
        
    - 共享内存（shared memory）
        
    - 信号量（semaphore）
        
    - 套接字（socket）
        
    - 信号（signal）
        

**延伸补充：**  
Java 中的多进程通信可通过 socket 或文件系统实现。  
例如 Tomcat 的多实例通信、分布式系统中的 RPC、消息队列（Kafka/RabbitMQ）等。

---

### 🔢 3. 三线程打印 1~9

**一眼记忆点：**  
Condition + 共享变量 + 模运算控制。

**理解思路：**

- 设置一个共享变量 `num = 1`。
    
- 每个线程在循环中：
    
    - 先加锁；
        
    - 判断是否轮到自己（`num % 3 == 线程编号`）；
        
    - 如果不是，就 `await()`；
        
    - 如果是，就打印并 `num++`；
        
    - 然后 `signalAll()` 唤醒其他线程。
        

**延伸补充（可口述伪代码）**：

```java
class PrintTask implements Runnable {
    private int id;
    private static int num = 1;
    private static final Lock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();

    public void run() {
        while (num <= 9) {
            lock.lock();
            try {
                while ((num - 1) % 3 != id) condition.await();
                System.out.println(Thread.currentThread().getName() + "：" + num++);
                condition.signalAll();//唤醒不等于立刻执行，唤醒只是让它们重新竞争锁。
            } finally {
                lock.unlock();
            }
        }
    }
}

```

**延伸面试点：**

- 面试官常会追问：“如果用 `synchronized` 和 `wait/notify` 呢？”
    
- 也可提到 `CyclicBarrier`、`Semaphore` 实现。

---

### ⚙️ 4. 操作系统调度：进程 vs 线程

**一眼记忆点：**  
进程独立、线程轻量；PCB vs TCB；进程安全、线程高效。

**理解思路：**

|比较项|进程|线程|
|---|---|---|
|独立性|独立地址空间|共享进程空间|
|调度单位|PCB（进程控制块）|TCB（线程控制块）|
|切换代价|高（页表切换）|低（寄存器上下文）|
|稳定性|互不影响|共享内存易崩溃|
|调度粒度|操作系统级别|CPU 调度级别|

**延伸补充：**

- JVM 层面：JVM 线程直接映射到 OS 线程，由 OS 进行调度。
    
- 线程调度算法常用 “时间片轮转 + 优先级” 模式。

---

### 🌐 5. 浏览器标签页与进程

**一眼记忆点：**  
现代浏览器是多进程架构。

**理解思路：**

- Chrome/Edge 等采用“多进程 + 多线程”模型。
    
- 常见进程：浏览器主进程、GPU 进程、插件进程、网络进程、渲染进程。
    
- 同一站点可共享渲染进程（Site Isolation 优化）。
    

**延伸补充：**  
这样设计的优点：

- 崩溃隔离：某个标签挂了不影响整体。
    
- 安全性：沙盒机制保护内核。
    
- 并行能力更强。
    

---

### 🧩 6. 用户态与系统态的转换

**一眼记忆点：**  
系统调用是“从用户态到内核态”的唯一合法入口。

**理解思路：**

- 用户态程序不能直接访问硬件。
    
- 当执行诸如 `read()`、`write()`、`fork()`、`exec()` [[“系统调用”函数|这些操作]]时，会触发**陷入指令（trap）** → 进入[[内核态]]。
    
- 内核完成操作后再返回用户态。

**延伸补充：**

- 系统调用是通过软中断（如 `int 0x80`）实现的。
    
- Linux 中的系统调用由 syscall table 管理。
    
- 用户态切换代价较高，JVM/数据库/操作系统优化时都要减少系统调用次数。


---

### 🔄 7. 进程的几种状态

**一眼记忆点：**  
创建 → 就绪 → 运行 → 阻塞 → 唤醒 → 终止。

**理解思路：**

- **创建态**：正在创建资源；
    
- **就绪态**：等待调度；
    
- **运行态**：获得 CPU 执行；
    
- **阻塞态**：等待 I/O 或信号；
    
- **唤醒态**：条件满足，重新进入就绪；
    
- **终止态**：执行完或被杀死。
    

**延伸补充：**  
可画一个经典状态转换图（面试加分点👇）：

```
     创建
       ↓
     就绪 ←—— 唤醒 ←—— 阻塞
       ↓             ↑
      运行 ——→ 阻塞
       ↓
     终止

```


---

### ✅ 整体记忆顺序建议：

| 阶段  | 内容    | 记忆关键词          |
| --- | ----- | -------------- |
| 入门  | 1 + 2 | 进程线程定义 + 通信方式  |
| 编程  | 3     | 多线程协作打印        |
| 核心  | 4 + 6 | 调度机制 + 用户态内核态  |
| 拓展  | 5 + 7 | 浏览器多进程架构 + 状态机 |
